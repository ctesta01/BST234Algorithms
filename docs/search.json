[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Structures and Algorithms (BST 234) Notes",
    "section": "",
    "text": "Building 2, room 435\nResearch interests: algorithmic mathematics and statistics, efficient and randomized algorithms, methodology development, multiple testing, NP-complete problems.\nTA: Max Wang\nTake home midterm and final presentation project.\nWeek after of Spring Break is midterm."
  },
  {
    "objectID": "week1/week1.html",
    "href": "week1/week1.html",
    "title": "2  Week 1: Intro",
    "section": "",
    "text": "What is an algorithm?\n\nA (finite) sequence of instructions that transforms some (well-specified) input into (well-specified) output.\n\nDefinition from wikipedia:\n\nIn mathematics and computer science, an algorithm is an effective method expressed as a finite list of well-defined instructions for calculating a function.\n\nAlgorithm = “A tool for solving a well-defined computational problem”\nAlgorithm \\(f:\\) input \\(\\to\\) output.\nProperties?\n\nRun-time (time complexity)\nSpace complexity (how much disk space is taken up)\n\nSorting can be done in place\n\nDecideability\n\nWhen a computer gets to a step, it has to know what to do.\n\n\nOften time and space complexity play off each other.\nRhetorical appeal: just look on Instagram — we store so much stuff. Apparently space is cheap.\n1. do x \n   or do y \n\n# not an algorithm\n1. flip coin \n2. if heads -> x \n      tails -> y\n\n# is an algorithm\nRandomness comes in different flavors:\n\nQuicksort is a method that always sorts, but its run-time is random.\nMCMC uses randomness in the result, because if we run it twice the results are different.\n\nRuntime and correctness are the gold-standard in methodology development. Prove runtime, prove correctness in the p-sets.\nInput: a set of numbers \\(\\langle a_1, a_2, ..., a_n \\rangle\\).\nOutput: Sorted sequence of input data \\(\\langle a_1', a_2', ..., a_n' \\rangle\\) with \\(a_1' \\leq ... \\leq a_n'\\).\nA sorting algorithm \\(f\\) solves the problem defined by the input-output relationship.\nThere are many sorting techniques."
  },
  {
    "objectID": "index.html#goals-for-the-course",
    "href": "index.html#goals-for-the-course",
    "title": "Data Structures and Algorithms (BST 234) Notes",
    "section": "0.1 Goals for the course",
    "text": "0.1 Goals for the course\nIntroduction to important computational problems in computer science (biostatistics) and state of the art algorithms for solving them.\nUnderstanding of data structures and algorithms to solve problems of practical relevance.\nUnderstanding of mathematical standards for numerical analysis and statistics, inclusding their implementations.\nKnowledge of R and Python is vital (lab sessions).\nWhy is it always “Data Structures And Algorithms”?\nBecause the two are intrinsically linked; they don’t mean much without the other.\nWhy? Because the algorithm may run much faster or slower depending on the data structure.\nFor example, we might have a list. Or we might have a hash-map. Some things are fast in lists, whereas different things are fast in a hash-map.\nOften we have an end-pointer if we have a doubly-linked list.\nFor example, popping the first element, or last element, these are \\(O(1)\\) operations (including updating pointers). In contrast, searching is an \\(O(n)\\) operation when traversing.\nIf we have a binary tree (heap), then searching is \\(O(\\log_2 n )\\).\nWe will use the Cormen, Leiserson, Rivest, Stein. CLLS. Available for free on HOLLIS.\nContents\n\nIntroduction, random numbers\nConcepts of algorithms, complexity and sorting algorithms\nData structures and heapsort\nGreedy algorithms and dynamic programming\nIntroduction to parallel programming\nP and NP\nNumerical aspects of computer algorithms, condition of a problem, numerical stability of an algorithm, numerical error, forward/backward-error\nEfficient algorithms for linear algebra\nLeast-Squares Program, Eigenvalue Decomposition\nNumerical integration, Monte Carlo integration, importance sampling\nNumerical optimization\nWork on projects\nProject presentations"
  },
  {
    "objectID": "week1/week1.html#section",
    "href": "week1/week1.html#section",
    "title": "2  Week 1: Intro",
    "section": "2.1 ",
    "text": "2.1 \nAn iconic algorithm:\n\nfunction gcd(a,b): \n  while a ≠ b:\n    if a > b:\n      a := a-b\n    else: \n      b := b-a\n  return a\n\ngcd: 20, 15 -> 5 \n\na = 20, b = 15 \na = 5, b = 15, \na = 5, b = 1 \na = 5, b = 5\n\nThis algorithm is the greatest common divisor.\nThis is used in encryption and it is still the fastest algorithm.\nFrom ~300 BC from Euclid of Alexandria.\nExamples of algorithms:\n\nSorting Algorithms\nOptimization Problems:\n\nTraveling salesman: chip design, airline schedule\n\nMathematical problems:\n\nSolution of linear equations / matrix algebra\nIntegration\n\nStatistical problems\n\nOptimal designs / power calculations\nComputation of distributions\nComputation of test statistics\n\n\nExamples:\n\nEuclid GCD\nPagerank\nGradient descent\n\nLocal minimum\n\nBellman; Ford; shortest path and allow negative weights\nDjikstra\nCompression\nWord2Vec\nShannon Encoding for Transmission Errors\nTower of Hanoi\n\nRecursive\n\n\nGeorg’s hit-list:\n\nEuclid\nQuadratic Sieve\nBerlekamp\nCantor-Zassehaus\n\nFactoring numbers is super-polynomial but sub-exponential. It’s like almost exponential. This doesn’t go for factoring polynomials.\nWhen multiplying numbers, all the terms get jumbled up whereas we know where the pieces came from in polynomials:\n(123 * 827) = (1*10^2 + 2 * 10^2 + 3 * 10^0 ) * (...)\n\nvs. \n\n(2x + 3)(x^2 + 1)\n\nWhat do random numbers and compression have in common?\n\nProperties of Algorithms\n\nFeasibility\nTermination\nDeterministic\nFinite\n\nAlgorithms work on dynamic sets of elements (input -> output):\n\nSearching, inserting and deleting elements\nMaximum, minimum element\n\nData structures are used for the implementation of dynamic datasets. The efficiency of a data structure can depend on the desired manipulation operation.\nExamples of data structures:\n\nArray: access to elements based on index\n\nContinuous allocated memory, evenly divided\n\nLinked List: reference / pointer to the next element\nStack: dynamic set of elements, last in first out\nQueue: dynamic set of elements, can only be read starting from most longest added element, first-in-first-out\nGraphs or Trees: elements have references/pointers to a variable number of other elements"
  }
]